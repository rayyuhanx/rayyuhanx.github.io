<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>你需要知道的5个常见泛型 | BLOG</title><meta name="description" content="Development. 面白いこと. Game life."><meta name="keywords" content="Blog,Development.,面白いこと.,Game life."><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" href="/atom.xml" title="BLOG"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="List表示为一个可以通过索引访问的列表，说明它是泛型列表。相比数组(Array)，它的长度不是固定的，可以根据内容的增长而变长，所以它有另外的称呼：动态数组、矢量列表。在列表内部，其实也是使用了Array，如果当这个Array内容达到长度上限时，List会创建一个更大的Array，然后将以前的数据，全部Copy过去。你可以在声明List时，指明 容量(capacity) ，在已知长度的情况下，可"><meta name="keywords" content="CSharp,译文"><meta property="og:type" content="article"><meta property="og:title" content="你需要知道的5个常见泛型"><meta property="og:url" content="http://yoursite.com/_/Tech/CSharp/5-common-Generics/index.html"><meta property="og:site_name" content="BLOG"><meta property="og:description" content="List表示为一个可以通过索引访问的列表，说明它是泛型列表。相比数组(Array)，它的长度不是固定的，可以根据内容的增长而变长，所以它有另外的称呼：动态数组、矢量列表。在列表内部，其实也是使用了Array，如果当这个Array内容达到长度上限时，List会创建一个更大的Array，然后将以前的数据，全部Copy过去。你可以在声明List时，指明 容量(capacity) ，在已知长度的情况下，可"><meta property="og:locale" content="en"><meta property="og:updated_time" content="2019-07-16T05:40:46.756Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="你需要知道的5个常见泛型"><meta name="twitter:description" content="List表示为一个可以通过索引访问的列表，说明它是泛型列表。相比数组(Array)，它的长度不是固定的，可以根据内容的增长而变长，所以它有另外的称呼：动态数组、矢量列表。在列表内部，其实也是使用了Array，如果当这个Array内容达到长度上限时，List会创建一个更大的Array，然后将以前的数据，全部Copy过去。你可以在声明List时，指明 容量(capacity) ，在已知长度的情况下，可"><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="/css/waves.min.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head></html><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>setLoadingBarProgress(20)</script><header class="l_header"><div class="wrapper"><div class="nav-main container container--flex"><a class="logo flat-box" href="/">BLOG</a><div class="menu"><ul class="h-list"><li><a class="flat-box nav-home" href="/">Home</a></li></ul><div class="underline"></div></div><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="Search"> <span class="icon icon-search"></span></form></div><ul class="switcher h-list"><li class="s-search"><a href="javascript:void(0)"><span class="icon icon-search flat-box"></span></a></li><li class="s-menu"><a href="javascript:void(0)"><span class="icon icon-menu flat-box"></span></a></li></ul></div><div class="nav-sub container container--flex"><a class="logo" href="javascript:void(0)">Word of Forks</a><ul class="switcher h-list"><li class="s-comment"><a href="javascript:void(0)"><span class="icon icon-chat_bubble_outline flat-box"></span></a></li><li class="s-top"><a href="javascript:void(0)"><span class="icon icon-arrow_upward flat-box"></span></a></li><li class="s-toc"><a href="javascript:void(0)"><span class="icon icon-format_list_numbered flat-box"></span></a></li></ul></div></div></header><aside class="menu-phone"><nav><a href="/" class="nav-home nav">Home</a></nav></aside><script>setLoadingBarProgress(40)</script><div class="l_body"><div class="container clearfix"><div class="l_main"><article id="post-Tech/CSharp/5-common-Generics" class="post white-box article-type-post" itemscope itemprop="blogPost"><section class="meta"><h2 class="title"><a href="/_/Tech/CSharp/5-common-Generics/">你需要知道的5个常见泛型</a></h2><time>2019-07-15</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在列表开头或者中间增-删"><span class="toc-number">1.1.</span> <span class="toc-text">在列表开头或者中间增/删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在列表末尾增-删"><span class="toc-number">1.2.</span> <span class="toc-text">在列表末尾增/删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在列表中搜索一个元素"><span class="toc-number">1.3.</span> <span class="toc-text">在列表中搜索一个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用下标访问一个元素"><span class="toc-number">1.4.</span> <span class="toc-text">使用下标访问一个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-in-a-Nutshell"><span class="toc-number">1.5.</span> <span class="toc-text">List in a Nutshell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dictionary-lt-TKey-TValue-gt"><span class="toc-number">2.</span> <span class="toc-text">Dictionary&lt;TKey, TValue&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-number">3.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">4.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">5.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在最后"><span class="toc-number">6.</span> <span class="toc-text">写在最后</span></a></li></ol></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List<t></t></h2><p>表示为一个可以通过索引访问的列表，<t>说明它是泛型列表。相比数组(Array)，它的长度不是固定的，可以根据内容的增长而变长，所以它有另外的称呼：动态数组、矢量列表。在列表内部，其实也是使用了Array，如果当这个Array内容达到长度上限时，List会创建一个更大的Array，然后将以前的数据，全部Copy过去。你可以在声明List时，指明 <code>容量(capacity)</code> ，在已知长度的情况下，可以节省一些内存(原理是，降低内部重新创建Array，重新分配)</t></p><figure class="highlight csharp"><figcaption><span>List示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为200的泛型</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// 通过下标获取泛型第一个元素</span></span><br><span class="line"><span class="keyword">var</span> first = list[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 是否包含某元素</span></span><br><span class="line"><span class="keyword">var</span> is_contains = list.Contains(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 循环每个元素</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：萌新请勿直接copy代码执行，List需要赋值之后才能使用</span></span><br><span class="line"><span class="comment">// 参数那里给的200，只是表示容量，声明变量之后不会默认用 null 填充</span></span><br><span class="line"><span class="comment">// 报错类型：ArgumentOutOfRangeException</span></span><br></pre></td></tr></table></figure><h3 id="在列表开头或者中间增-删"><a href="#在列表开头或者中间增-删" class="headerlink" title="在列表开头或者中间增/删"></a>在列表开头或者中间增/删</h3><p>如果你要在一个列表的开头或者中间做增加/删除操作，列表就会从它内部的Array中移除(shift)一个或多个元素。对于你在列表的最前面的位置增删的话，那将会很糟糕，因为它会移除所有存在的元素。并且，如果列数容量越大，内存消耗也就越大，这种操作的消耗表示为：<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" target="_blank" rel="noopener">Big O notation:</a><strong>O(n)</strong>。简单的说就是，容量越大，消耗越大，呈线性增长。</p><h3 id="在列表末尾增-删"><a href="#在列表末尾增-删" class="headerlink" title="在列表末尾增/删"></a>在列表末尾增/删</h3><p>如果在末尾进行操作的话，相对来说会更快，并且内存消耗和容量无关，因为已存在的元素不用必须移除。这也是为什么说在这里操作相对更快，并且和列表的容量无关了。我们把这种操作的消耗表示为：<strong>O(1)</strong></p><h3 id="在列表中搜索一个元素"><a href="#在列表中搜索一个元素" class="headerlink" title="在列表中搜索一个元素"></a>在列表中搜索一个元素</h3><p>每当我们使用到搜索的方法时(比如：<strong>IndexOf</strong>、<strong>Contains</strong>或<strong>Find</strong>)，列表执行的是线性搜索。这就意味着，它将会遍历内部Array的所有元素，直到其中的一个与你想要的相匹配。在最糟糕的情况，如果你需要的刚好在末尾，那将会遍历前面所有的元素。所以，这种操作的运行复杂度也是：<strong>O(n)</strong></p><h3 id="使用下标访问一个元素"><a href="#使用下标访问一个元素" class="headerlink" title="使用下标访问一个元素"></a>使用下标访问一个元素</h3><p>当你使用下标去操作一个元素的时候，这种操作和容量是不相关的。并且这也是列表比较好的一点，这种消耗也表示为：<strong>O(1)</strong></p><h3 id="List-in-a-Nutshell"><a href="#List-in-a-Nutshell" class="headerlink" title="List in a Nutshell"></a>List in a Nutshell</h3><p>在末尾增/删和通过下标访问元素的消耗为：<strong>O(1)</strong>，在列表中搜索元素，最糟糕的时候消耗为：<strong>O(n)</strong>。如果你想根据某些条件搜索的话，可以使用 <strong>Dictionary</strong></p><h2 id="Dictionary-lt-TKey-TValue-gt"><a href="#Dictionary-lt-TKey-TValue-gt" class="headerlink" title="Dictionary&lt;TKey, TValue&gt;"></a>Dictionary&lt;TKey, TValue&gt;</h2><p>字典(Dictionary)比较适用于你想使用键(TKey)快速定位到指定项，比如你有一个客户集合，你想用他们的ID快速得到具体信息。对于列表(List)的话，这个操作就会更复杂，消耗更多的内存，就像上面说的，最糟糕时的消耗为：<strong>O(n)</strong>。然而对于字典，这样的搜索会非常快(<strong>O(1)</strong>)，不管字典有多大，消耗都是保持不变的。当在字典中保存或者检索一个对象时，你需要提供一个唯一的并且不为空的键。</p><figure class="highlight csharp"><figcaption><span>Dictionary示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个字典</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, Customer&gt;();</span><br><span class="line"><span class="comment">// 定义并且给一些初始值</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, Customer&gt; </span><br><span class="line">&#123;</span><br><span class="line">  &#123; customer1.Id, customer1 &#125;,</span><br><span class="line">  &#123; customer2.Id, customer2 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用键获取元素</span></span><br><span class="line"><span class="keyword">var</span> customer = dic[<span class="number">111</span>];</span><br><span class="line"><span class="comment">// 使用键移除元素</span></span><br><span class="line">dic.Remove(<span class="number">111</span>);</span><br><span class="line"><span class="comment">// 清空字典</span></span><br><span class="line">dic.Clear();</span><br><span class="line"><span class="comment">// 是否包含键</span></span><br><span class="line"><span class="keyword">var</span> contains_key = dic.ContainsKey(<span class="number">111</span>);</span><br><span class="line"><span class="comment">// 是否包含值</span></span><br><span class="line"><span class="keyword">var</span> contains_value = dic.ContainsValue(customer1);</span><br></pre></td></tr></table></figure><p>可是，为什么字典搜索为更快呢？字典内部也是使用了一个Array存储对象。但是列表每次在增加元素的时候，都把对象添加在末尾(或者指定下标)。而字典每次存储时会用 <strong>散列(GetHashCode)</strong> 计算出一个值，并且用这个值来调整内部Array的长度，然后使用这个值当作索引存储对象。之后，我们每次使用下标查找元素的时候，字典会再次调用<strong>GetHashCode</strong>，计算我们提供的键，用于查找到指定的对象。上面我们说过，使用下标访问元素，这样的消耗为：<strong>O(1)</strong>。所以不想列表需要遍历所有的对象，这也是为什么字典更快的原因。</p><figure class="highlight csharp"><figcaption><span>大致实现概念</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部数组</span></span><br><span class="line"><span class="keyword">var</span> inner_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 提供一个键</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="string">"TheKey"</span>;</span><br><span class="line"><span class="comment">// 来自 dictionary.cs</span></span><br><span class="line"><span class="keyword">var</span> hash = key.GetHashCode() &amp; <span class="number">0x7FFFFFFF</span> % <span class="number">0x255</span>;</span><br><span class="line"><span class="comment">// 需要存放的值</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="number">666</span>;</span><br><span class="line"><span class="comment">// 创建新数组</span></span><br><span class="line"><span class="keyword">var</span> newBuckets = <span class="keyword">new</span> <span class="keyword">int</span>[hash];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash; i++) newBuckets[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 存储对象</span></span><br><span class="line">newBuckets[hash - <span class="number">1</span>] = val;</span><br><span class="line"><span class="comment">// 数组赋值</span></span><br><span class="line">inner_array = newBuckets;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Console.WriteLine(inner_array[hash - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet<t></t></h2><p>散列集(HashSet)，正如其名，存放的元素不能重复的集合。比如：<strong>{1,2,3}</strong>，而且具有顺序无关性，也就是说，<strong>{1,2,2}</strong> 和 <strong>{3,2,1}</strong>是相等的。散列集一般适用于追求超快检索，内容唯一时，比如你有一个订单集合，对于某一订单，你需要快速找到其对应的供应商。散列集和字典有点类似，都是 <strong>基于散列的集合</strong>，所以在查找时消耗都为：<strong>O(1)</strong>。但是散列值只能存放值，而不像字典存放的是键值对。两个个对象是否相等，取决于它们调用 <strong>GetHashCode</strong> 返回的结果。所以，如果你要使用散列集存储自定义的类，你需要去重写 <strong>GetHashCode</strong> 和 <strong>Equals</strong> 这两个方法。</p><figure class="highlight csharp"><figcaption><span>HashSet示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个HashSet</span></span><br><span class="line"><span class="keyword">var</span> hashSet = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="comment">// 增加一个对象</span></span><br><span class="line">hashSet.Add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">hashSet.Clear();</span><br><span class="line"><span class="comment">// HashSet和List的操作大多类似，但是它提供了一些数学运算操作：</span></span><br><span class="line"><span class="keyword">var</span> _1st = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> _2nd = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 两个集合共有的：_1st = &#123; 1 &#125;</span></span><br><span class="line">_1st.IntersectWith(_2nd);</span><br><span class="line"><span class="comment">// 移除两个集合共有的： _1st = &#123; 2, 6 &#125;</span></span><br><span class="line">_1st.ExceptWith(_2nd);</span><br><span class="line"><span class="comment">// 合并两个集合取并集： _1st = &#123; 1, 2, 6 &#125;</span></span><br><span class="line">_1st.UnionWith(_2nd);</span><br><span class="line"><span class="comment">// 还有IsSupersetOf、IsSubsetOf、SetEquals等等</span></span><br></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack<t></t></h2><p>栈(Stack)是一个后进先出(LIFO)的集合，一般使用场景为用户需要可回退功能时。最常见的就是浏览器，你进入新的网址之后，你可以点击后退，返回上一个网址，还有一些就是比如IDE的Ctrl+Z。</p><figure class="highlight csharp"><figcaption><span>Stack示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个Stack</span></span><br><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="comment">// 添加一个新元素</span></span><br><span class="line">stack.Push(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="comment">// 是否包含某元素</span></span><br><span class="line"><span class="keyword">var</span> is_contains = stack.Contains(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="comment">// 获取末尾元素并删除</span></span><br><span class="line"><span class="keyword">var</span> last_with_delete = stack.Pop();</span><br><span class="line"><span class="comment">// 获取最后一个元素不删除</span></span><br><span class="line"><span class="keyword">var</span> last_without_delete = stack.Peek();</span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure><p>在栈的内部，初始化的时候会声明一个有容量的Array，当你Push一个元素时，如果达到了容量上限，就需要创建一个更大的Array，并且copy以前所有存在的元素，这样的消耗为：<strong>O(n)</strong>。但是，当没达到时，消耗为：<strong>O(1)</strong></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue<t></t></h2><p>与栈不同的是，队列(Queue)是一个先进先出(FIFO)的集合，一般在按顺序执行任务时时候，比如消息队列之类的。<br></p><figure class="highlight csharp"><figcaption><span>Queue示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个队列</span></span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="comment">// 加入队列</span></span><br><span class="line">queue.Enqueue(<span class="string">"task1"</span>);</span><br><span class="line"><span class="comment">// 判断是否包含</span></span><br><span class="line"><span class="keyword">var</span> is_contains = queue.Contains(<span class="string">"taks2"</span>);</span><br><span class="line"><span class="comment">// 获取第一个任务并从队列中删除</span></span><br><span class="line"><span class="keyword">var</span> first_with_delete = queue.Dequeue();</span><br><span class="line"><span class="comment">// 获取第一个任务不删除</span></span><br><span class="line"><span class="keyword">var</span> first_without_delete = queue.Peek();</span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure><p></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>列表(List)使用下标查找元素很快，但是使用搜索的话，就会变慢。<br>字典(Dictionary)提供使用键快速索引出对象，键必须唯一且不能为空。<br>散列集(HashSet)用在需要快速查找元素是否存在时表现得很不错。<br>栈(Stack)的存储方式是LIFO，所以一般遇到可回退，或者撤销之类的情况下。<br>队列(Queue)则是FIFO，用户处理任务以此执行就很合适。</p><a href="https://programmingwithmosh.com/net/csharp-collections/" target="_blank" rel="noopener">原文在这里</a></div><div class="article-tags tags"><a href="/tags/CSharp/">CSharp</a> <a href="/tags/译文/">译文</a></div><div class="art-item-footer"><span class="art-item-right">next：<a href="/_/Tech/Hexo/hello-world/" rel="next" title="Hello World"> Hello World </a><i class="icon icon-chevron-thin-right"></i></span></div></section></article><script>window.subData={title:"你需要知道的5个常见泛型",tools:!0}</script></div></div></div><footer id="footer" class="clearfix"><div class="social-wrapper"></div><div>Theme <a href="https://github.com/stkevintan/hexo-theme-material-flow" class="codename">MaterialFlow</a> designed by <a href="https://github.com/stkevintan" target="_blank">Kevin Tan</a>.</div></footer><script>setLoadingBarProgress(80)</script><script src="/js/jquery.min.js"></script><script src="/js/waves.min.js"></script><script src="/js/scrollreveal.min.js"></script><script src="/js/jquery.fitvids.js"></script><script>var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>setLoadingBarProgress(100)</script></body>