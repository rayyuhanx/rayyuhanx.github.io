{"pages":[],"posts":[{"title":"你需要知道的5个常见泛型","permalink":"http://yoursite.com/_/Tech/CSharp/5-common-Generics/","text":"List表示为一个可以通过索引访问的列表，说明它是泛型列表。相比数组(Array)，它的长度不是固定的，可以根据内容的增长而变长，所以它有另外的称呼：动态数组、矢量列表。在列表内部，其实也是使用了Array，如果当这个Array内容达到长度上限时，List会创建一个更大的Array，然后将以前的数据，全部Copy过去。你可以在声明List时，指明 容量(capacity) ，在已知长度的情况下，可以节省一些内存(原理是，降低内部重新创建Array，重新分配)List示例代码12345678910111213// 创建一个容量为200的泛型var list = new List&lt;string&gt;(200);// 通过下标获取泛型第一个元素var first = list[0];// 是否包含某元素var is_contains = list.Contains(1);// 循环每个元素foreach(var item in list) Console.WriteLine(item);// 注：萌新请勿直接copy代码执行，List需要赋值之后才能使用// 参数那里给的200，只是表示容量，声明变量之后不会默认用 null 填充// 报错类型：ArgumentOutOfRangeException在列表开头或者中间增/删如果你要在一个列表的开头或者中间做增加/删除操作，列表就会从它内部的Array中移除(shift)一个或多个元素。对于你在列表的最前面的位置增删的话，那将会很糟糕，因为它会移除所有存在的元素。并且，如果列数容量越大，内存消耗也就越大，这种操作的消耗表示为：Big O notation:O(n)。简单的说就是，容量越大，消耗越大，呈线性增长。在列表末尾增/删如果在末尾进行操作的话，相对来说会更快，并且内存消耗和容量无关，因为已存在的元素不用必须移除。这也是为什么说在这里操作相对更快，并且和列表的容量无关了。我们把这种操作的消耗表示为：O(1)在列表中搜索一个元素每当我们使用到搜索的方法时(比如：IndexOf、Contains或Find)，列表执行的是线性搜索。这就意味着，它将会遍历内部Array的所有元素，直到其中的一个与你想要的相匹配。在最糟糕的情况，如果你需要的刚好在末尾，那将会遍历前面所有的元素。所以，这种操作的运行复杂度也是：O(n)使用下标访问一个元素当你使用下标去操作一个元素的时候，这种操作和容量是不相关的。并且这也是列表比较好的一点，这种消耗也表示为：O(1)List in a Nutshell在末尾增/删和通过下标访问元素的消耗为：O(1)，在列表中搜索元素，最糟糕的时候消耗为：O(n)。如果你想根据某些条件搜索的话，可以使用 DictionaryDictionary&lt;TKey, TValue&gt;字典(Dictionary)比较适用于你想使用键(TKey)快速定位到指定项，比如你有一个客户集合，你想用他们的ID快速得到具体信息。对于列表(List)的话，这个操作就会更复杂，消耗更多的内存，就像上面说的，最糟糕时的消耗为：O(n)。然而对于字典，这样的搜索会非常快(O(1))，不管字典有多大，消耗都是保持不变的。当在字典中保存或者检索一个对象时，你需要提供一个唯一的并且不为空的键。Dictionary示例代码123456789101112131415161718// 定义一个字典var dic = new Dictionary&lt;int, Customer&gt;();// 定义并且给一些初始值var dic = new Dictionary&lt;int, Customer&gt; &#123; &#123; customer1.Id, customer1 &#125;, &#123; customer2.Id, customer2 &#125;&#125;;// 使用键获取元素var customer = dic[111];// 使用键移除元素dic.Remove(111);// 清空字典dic.Clear();// 是否包含键var contains_key = dic.ContainsKey(111);// 是否包含值var contains_value = dic.ContainsValue(customer1);可是，为什么字典搜索为更快呢？字典内部也是使用了一个Array存储对象。但是列表每次在增加元素的时候，都把对象添加在末尾(或者指定下标)。而字典每次存储时会用 散列(GetHashCode) 计算出一个值，并且用这个值来调整内部Array的长度，然后使用这个值当作索引存储对象。之后，我们每次使用下标查找元素的时候，字典会再次调用GetHashCode，计算我们提供的键，用于查找到指定的对象。上面我们说过，使用下标访问元素，这样的消耗为：O(1)。所以不想列表需要遍历所有的对象，这也是为什么字典更快的原因。大致实现概念1234567891011121314151617// 内部数组var inner_array = new int[0];// 提供一个键var key = \"TheKey\";// 来自 dictionary.csvar hash = key.GetHashCode() &amp; 0x7FFFFFFF % 0x255;// 需要存放的值var val = 666;// 创建新数组var newBuckets = new int[hash];for (int i = 0; i &lt; hash; i++) newBuckets[i] = -1;// 存储对象newBuckets[hash - 1] = val;// 数组赋值inner_array = newBuckets;// 输出结果Console.WriteLine(inner_array[hash - 1]);HashSet散列集(HashSet)，正如其名，存放的元素不能重复的集合。比如：{1,2,3}，而且具有顺序无关性，也就是说，{1,2,2} 和 {3,2,1}是相等的。散列集一般适用于追求超快检索，内容唯一时，比如你有一个订单集合，对于某一订单，你需要快速找到其对应的供应商。散列集和字典有点类似，都是 基于散列的集合，所以在查找时消耗都为：O(1)。但是散列值只能存放值，而不像字典存放的是键值对。两个个对象是否相等，取决于它们调用 GetHashCode 返回的结果。所以，如果你要使用散列集存储自定义的类，你需要去重写 GetHashCode 和 Equals 这两个方法。HashSet示例代码12345678910111213141516// 定义一个HashSetvar hashSet = new HashSet&lt;int&gt;();// 增加一个对象hashSet.Add(1);// 清空hashSet.Clear();// HashSet和List的操作大多类似，但是它提供了一些数学运算操作：var _1st = new HashSet&lt;int&gt; &#123; 1, 2 &#125;;var _2nd = new HashSet&lt;int&gt; &#123; 1, 6 &#125;;// 两个集合共有的：_1st = &#123; 1 &#125;_1st.IntersectWith(_2nd);// 移除两个集合共有的： _1st = &#123; 2, 6 &#125;_1st.ExceptWith(_2nd);// 合并两个集合取并集： _1st = &#123; 1, 2, 6 &#125;_1st.UnionWith(_2nd);// 还有IsSupersetOf、IsSubsetOf、SetEquals等等Stack栈(Stack)是一个后进先出(LIFO)的集合，一般使用场景为用户需要可回退功能时。最常见的就是浏览器，你进入新的网址之后，你可以点击后退，返回上一个网址，还有一些就是比如IDE的Ctrl+Z。Stack示例代码123456789101112// 声明一个Stackvar stack = new Stack&lt;string&gt;();// 添加一个新元素stack.Push(\"https://www.google.com\");// 是否包含某元素var is_contains = stack.Contains(\"https://www.google.com\");// 获取末尾元素并删除var last_with_delete = stack.Pop();// 获取最后一个元素不删除var last_without_delete = stack.Peek();// 清空栈stack.Clear();在栈的内部，初始化的时候会声明一个有容量的Array，当你Push一个元素时，如果达到了容量上限，就需要创建一个更大的Array，并且copy以前所有存在的元素，这样的消耗为：O(n)。但是，当没达到时，消耗为：O(1)Queue与栈不同的是，队列(Queue)是一个先进先出(FIFO)的集合，一般在按顺序执行任务时时候，比如消息队列之类的。Queue示例代码123456789101112// 定义一个队列var queue = new Queue&lt;string&gt;();// 加入队列queue.Enqueue(\"task1\");// 判断是否包含var is_contains = queue.Contains(\"taks2\");// 获取第一个任务并从队列中删除var first_with_delete = queue.Dequeue();// 获取第一个任务不删除var first_without_delete = queue.Peek();// 清空队列queue.Clear();写在最后列表(List)使用下标查找元素很快，但是使用搜索的话，就会变慢。字典(Dictionary)提供使用键快速索引出对象，键必须唯一且不能为空。散列集(HashSet)用在需要快速查找元素是否存在时表现得很不错。栈(Stack)的存储方式是LIFO，所以一般遇到可回退，或者撤销之类的情况下。队列(Queue)则是FIFO，用户处理任务以此执行就很合适。原文在这里"},{"title":"Hello World","permalink":"http://yoursite.com/_/Tech/Hexo/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment"},{"title":"超级英雄 - PWA","permalink":"http://yoursite.com/_/Tech/Angular/super-pwa-hero/","text":"官方教程前面已经讲了 怎样成为 “Angular” 英雄 描述的是官方所给出的 Getting Started这次我们来说一下官方给出的另一个 Tutorial 步骤都很简单易懂，跟着做就行了，如果不喜欢看English的朋友，可以翻到底部切换语言或者也可以地址栏直接输入：https://angular.cn/tutorial而且官方还给出里 Live Demo https://stackblitz.com/angular/kooqabkbaknm变身 PWA在左侧菜单列表里面找到 Techniques -&gt; Service Workers &amp; PWA -&gt; Introduction 并打开。一开始讲了一下成为 PWA 的意义，然后说明 Angular 5.0.0 之后就支持 Service Worker，再说明了一下设计目的和使用CLI就可以创建变身条件官方这里这里说明了一下 Service worker 能在哪些浏览器能运行，比如 Chrome、Firefox、Safiri等等目前主流的浏览器，还提供了 Can I Use 和 MDN docs。我们大致知道变身所需要的条件，那我们开始吧，进入 Techniques -&gt; Service Workers &amp; PWA -&gt; Getting Started底部直链： Getting Started with service workers开始预热打开命令提示符，使用 ng 命令加入 PWA 支持123ng add @angular/pwa --project angular-tour-of-heroes# angular-tour-of-heroes 为项目名称，即 ng new 这里使用的名字# 如果忘记了可以在根目录的 angular.json - projects 下面找到你肯定也会好奇这条命令做了什么，下面就是它做的事：添加 @angular/service-worker 依赖，具体可在 package.json 文件查看在 CLI 中启用 Service Worker build support向 App Module 添加 Service Worker Module，详细在 app.moudle.ts 中查看修改 index.html 文件内容，包括在标签中加入 &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt; 和 &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;创建了 assetes 文件夹，并加入各类尺寸的 icons还创建了一个叫 ngsw-config.json 的 Service Worker 配置文件积蓄能量使用命令打包项目供后续调试使用12ng build --prod# --prod 以上线的方式打包，即release官方这里推荐使用 http-server 来做本地web服务器，如果你有更好的选择那自然随心http-server 安装命令如下：12npm install http-server -g# -g 表示全局安装这里我使用的是 lite-server，因为使用 http-server 遇到各种问题…lite-server 安装命令：1npm install lite-server -g等打包完毕之后，会在根目录创建一个 dist 的文件夹，自然你也可以在 angular.json 中配置 outputPathok，打开文件夹就知道，所有的都已经打包好了，可以开始部署了，下面使用 lite-server 开启服务12lite-server --baseDir=\"dist\"# -baseDir跟outputPath就行了，默认是dist123# http-server 命令如下：http-server -p 8080 -c-1 dist/&lt;project-name&gt;# -p 端口号 -c-1 表示禁用缓存 最后跟的是路径/项目名称(同上 添加PWA支持项目名)使用 lite-server 执行之后会使用默认浏览器打开，http-server 需要手动打开变身开打是时候表演真正的技术了，你可以使用虚拟机或者手机打开你刚刚部署的网站，但你首先保证你们在同一网域，做法很简单，要么手机开热点给电脑，要么连同一wifi，然后查看电脑ip，手机输入即可不出意外的话，打开之后功能都是存在的，而且都是能用的，这时候把手机的流量关掉刷新网页，你会才会发现变身之后有多强。关闭流量之后，你会惊讶的发现，什么？？？还能使用？？？这也太 IMBA 了吧！！没错，你看到了变身之后的 PWA 的真面目。还有一个很强大的地方就是 - app化，如果你使用的 Iphone 的话，试着使用 safari -&gt; 添加到主屏幕，然后你再打开桌面上新添加的图标，你会更兴奋的。附加链接非常值得一试！Google 官方出的 TutorialGoogle 官方给的 Mainifest.json还是Google 官方给的 Service Worker 介绍自然，以上链接都有中文，在顶部 Language 切换"},{"title":"怎样成为 “Angular” 英雄","permalink":"http://yoursite.com/_/Tech/Angular/become-an-angular-hero/","text":"PWA，第一步从Angular开始我这里使用的 Angular 版本为：stable v7.2.15，它的准备条件如下：nodejs version 8.x or 10.x.npm package manager(npm) 并没有要求版本，安装Nodejs的时候会一起安装如果你已经安装过，可以在命令提示符中通过以下命令查看：12345C:\\Users\\User&gt;node -vv11.12.0C:\\Users\\User&gt;npm -vv6.7.0安装 Angular CLI这是官方推出的脚手架工具，集成了你完成整个项目所需要的一切功能包括创建项目、生成应用和所依赖的库，再者就是测试、打包、发布，所以推荐全局安装(-g)在刚刚打开的命令提示符中输入如下命令：1npm install -g @angular/cli如果安装过程出现速度过慢，或者报错异常的问题，那推荐使用cnpm开始创建项目继续在命令提示符输入：123456# 在C盘创建一个叫 angluar 的文件夹并且 cd 到该目录mkdir c:\\angular &amp; cd c:\\angluar# 使用 ng 命令创建一个项目ng new my-app# 执行上面这条命令之后，会提示是否启用 Angluar routing和使用什么来写css# 如果不懂的或者不想看的直接一路回车即可，后续也会讲到怎么使用这些功能跑起最后两行代码：123456# 进入刚刚创建的项目，CLI会自动创建一个同名的文件夹cd my-app# 使用 ng 命令 run 起来ng serve --open# --open 表示使用默认浏览器打开，Angular默认监听的端口是4200# 可以通过 --port port 来指定你想监听的端口出现呐，那个“男人”官方的 Getting Started 到这里也就结束了，CLI 工具很简单易用三句代码就能创建一个能跑起来的项目，只是这文件夹嘛…"},{"title":"猜猜我是谁？PWA.","permalink":"http://yoursite.com/_/Tech/Angular/pwa-get-started/","text":"你在草丛遭遇了 - 铁甲蛹你的小火龙使用了 [利爪] - 效果一般最近一段时间接触到了 [PWA] 这个是在2015年，Google I/O 首次提出，它的特点如下：Full responsiveness and browser compatibility. These apps are built according to progressive enhancement principles. Progressive enhancement is the web design strategy of providing the basic functionality and content to everyone regardless of browsers they use or connection quality while delivering more sophisticated page versions to users whose newer browsers can support them.So, PWAs work with all browsers and are compatible with any device, regardless of screen size and other specifications. Tablet and mobile users will have the same experience. You can even adjust the app to the desktop if needed.Connectivity independence. Progressive web applications can work both offline and on low-quality networks.App-like interface. These apps mimic navigation and interactions of native apps.Push notifications. If used as a part of a good messaging strategy, push notifications can keep customers interested, motivating them to open and use an app more.Self-updates. Able to update themselves automatically, apps stay fresh.Safety. These apps are served through HTTPS, so unauthorized users can’t access their content.Discoverability and easy installation. While search engines classify PWAs as applications, they are not distributed via app stores. These apps can be shared through a URL instead so they’re easily found. The installation is simple and entails visiting a site and adding it to a device home screen.altexsoftwww.altexsoft.com/blog/engineering/progressive-web-apps你的小火龙使用了[火苗] - 效果拔群以上是英语版本的特点总结，自然也有比较友好的中文特点总结：渐进式 - 适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。自适应 - 适合任何机型：桌面设备，移动设备，平板电脑或任何未来设备。连接无关性 - 能够借助于服务工作线程(Service Worker)在离线或低质量网络状况下工作。类似应用 - 由于是在App Sheel模型基础下开发，因此具有应用风格的交互和导航，让用户有原生应用的感觉。持续更新 - 因为有服务工作线程的加持，能够时刻保持最新状态。安全 - 强制要求使用 HTTPS，以防止窥探和确保内容安全性。可发现 - 使用 W3C 指定的Mainfest和服务工作线程的作用，让搜索引擎找到它们的时候被识别为“应用”。可再互动 - 可以向用户推送通知。可安装 - 用户可以免去使用应用商店的麻烦，可以直接将其“保留”在主屏幕上。可链接 - 可以任意的通过链接分享给他人。你获得了 Official Case、 Official VideoOfficial Case Youtube Video"},{"title":"Windows服务内存监听","permalink":"http://yoursite.com/_/Dev/windows-service-memory-detector/","text":"起因一大早上班的时候，发现 chrome 浏览网页很卡，试着回收一下CommandChrome Commands1Chrome:://restart注: 此命令会关闭隐私窗口, 不能恢复…等 Chrome 重启之后，结果依然很卡…那就废话不多说，直接开大(Win + R)1C:\\Users\\User&gt; taskmgr发现是本地的 gitblit 居然吃了我 40w+的内存，这个明显不能忍啊，直接给它来一套: net stop gitblit只听 TaskManager 这样给我说： =&gt; 看来它已经懂我意思了想法突然灵光一闪，我能不能做一个自动检查服务内存，到了一定的阈值自动关闭呢？感觉是一个好想法，那就实现简单实现一下吧…经过一段时间的捣腾，火光四溅之后，代码已经打包压缩好了，链接在文末项目说明：我使用的是 Microsoft Visual Studio 2017(version 15.9.11)如果使用较低版本的朋友，可以直接打开里层目录的 .csproj 文件起主要作用的ClassServiceController 位于 System.ServiceProcess 命名空间下，需要手动添加引用这个类主要用于获取当前所有的Services，使用静态方法 GetServices 就能拿到所有的服务其中包括所有状态(Stopped、StartPending、StopPending、Running、ContinuePending、PausePending、Paused)还有 ServiceType 之分，详情请查阅 Enum - System.ServiceProcess.ServiceTypePerformanceCounter 它住在 System.Diagnostics，引入命名空间即可内存使用量的查询主要用到了它，这个类的构造函数第一个需要传入 categoryName，这个分类存在很多具体可在 性能监视器 查看，附上官网的例子，也可以使用 perfmon 查看，使用 Win + R 输入即可还有就是 ManagementObjectSearcher 住在 System.Management 也需要手动添加使用过 WMI 的应该都知道，简单点说就是如果你需要电脑的硬件信息，那很大可能你都会使用到它在项目中主要用于查询某个 Service 相关联的 ProcessId，因为服务的名称是可以自定义的运行的程序有可能名字不相同，所以需要去查询一下对应的Process源码Download"},{"title":"Hello Game","permalink":"http://yoursite.com/_/GVan/hello-game/","text":""},{"title":"从Hexo开始","permalink":"http://yoursite.com/_/Tech/Hexo/begin-with-hexo/","text":"flag从 1558407365744 开始, blog 开始启用, 用于记录日常学习的知识，还有一些生活相关。accomplice本博客使用 Hexo 引擎强力驱动，底部有此主题作者以及地址，再加上魔改一番，就出现了现在这个样子。action为什么要魔改呢，因为多半有病，强迫症太严重了，看到gen出来的 文件夹不规则 ，不符合自己的想法，一个字 改 ，主题里面 宽高 不符合自己的风格， 改!!!joke然后就出现了现在这个样子的博客，各位看官请将就着看，如果你们是 李荣浩 铁粉的话，右上角 (溜😅remarkHexo 初始化的 Hello World 并没有删除，希望更多人进入 Hexo 的世界。"}]}