<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>BLOG</title><meta name="description" content="Development. 面白いこと. Game life."><meta name="keywords" content="Blog,Development.,面白いこと.,Game life."><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" href="/atom.xml" title="BLOG"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Development. 面白いこと. Game life."><meta name="keywords" content="Blog,Development.,面白いこと.,Game life."><meta property="og:type" content="website"><meta property="og:title" content="BLOG"><meta property="og:url" content="http://yoursite.com/index.html"><meta property="og:site_name" content="BLOG"><meta property="og:description" content="Development. 面白いこと. Game life."><meta property="og:locale" content="en"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="BLOG"><meta name="twitter:description" content="Development. 面白いこと. Game life."><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="/css/waves.min.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head></html><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>setLoadingBarProgress(20)</script><header class="l_header"><div class="wrapper"><div class="nav-main container container--flex"><a class="logo flat-box" href="/">BLOG</a><div class="menu"><ul class="h-list"><li><a class="flat-box nav-home" href="/">Home</a></li></ul><div class="underline"></div></div><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="Search"> <span class="icon icon-search"></span></form></div><ul class="switcher h-list"><li class="s-search"><a href="javascript:void(0)"><span class="icon icon-search flat-box"></span></a></li><li class="s-menu"><a href="javascript:void(0)"><span class="icon icon-menu flat-box"></span></a></li></ul></div><div class="nav-sub container container--flex"><a class="logo" href="javascript:void(0)">Word of Forks</a><ul class="switcher h-list"><li class="s-comment"><a href="javascript:void(0)"><span class="icon icon-chat_bubble_outline flat-box"></span></a></li><li class="s-top"><a href="javascript:void(0)"><span class="icon icon-arrow_upward flat-box"></span></a></li><li class="s-toc"><a href="javascript:void(0)"><span class="icon icon-format_list_numbered flat-box"></span></a></li></ul></div></div></header><aside class="menu-phone"><nav><a href="/" class="nav-home nav">Home</a></nav></aside><script>setLoadingBarProgress(40)</script><div class="l_body"><div class="container clearfix"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Tech/CSharp/5-common-Generics/">你需要知道的5个常见泛型</a></h2><time>Jul 15, 2019</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="article typo"><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List<t></t></h2><p>表示为一个可以通过索引访问的列表，<t>说明它是泛型列表。相比数组(Array)，它的长度不是固定的，可以根据内容的增长而变长，所以它有另外的称呼：动态数组、矢量列表。在列表内部，其实也是使用了Array，如果当这个Array内容达到长度上限时，List会创建一个更大的Array，然后将以前的数据，全部Copy过去。你可以在声明List时，指明 <code>容量(capacity)</code> ，在已知长度的情况下，可以节省一些内存(原理是，降低内部重新创建Array，重新分配)</t></p><figure class="highlight csharp"><figcaption><span>List示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为200的泛型</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// 通过下标获取泛型第一个元素</span></span><br><span class="line"><span class="keyword">var</span> first = list[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 是否包含某元素</span></span><br><span class="line"><span class="keyword">var</span> is_contains = list.Contains(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 循环每个元素</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：萌新请勿直接copy代码执行，List需要赋值之后才能使用</span></span><br><span class="line"><span class="comment">// 参数那里给的200，只是表示容量，声明变量之后不会默认用 null 填充</span></span><br><span class="line"><span class="comment">// 报错类型：ArgumentOutOfRangeException</span></span><br></pre></td></tr></table></figure><h3 id="在列表开头或者中间增-删"><a href="#在列表开头或者中间增-删" class="headerlink" title="在列表开头或者中间增/删"></a>在列表开头或者中间增/删</h3><p>如果你要在一个列表的开头或者中间做增加/删除操作，列表就会从它内部的Array中移除(shift)一个或多个元素。对于你在列表的最前面的位置增删的话，那将会很糟糕，因为它会移除所有存在的元素。并且，如果列数容量越大，内存消耗也就越大，这种操作的消耗表示为：<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" target="_blank" rel="noopener">Big O notation:</a><strong>O(n)</strong>。简单的说就是，容量越大，消耗越大，呈线性增长。</p><h3 id="在列表末尾增-删"><a href="#在列表末尾增-删" class="headerlink" title="在列表末尾增/删"></a>在列表末尾增/删</h3><p>如果在末尾进行操作的话，相对来说会更快，并且内存消耗和容量无关，因为已存在的元素不用必须移除。这也是为什么说在这里操作相对更快，并且和列表的容量无关了。我们把这种操作的消耗表示为：<strong>O(1)</strong></p><h3 id="在列表中搜索一个元素"><a href="#在列表中搜索一个元素" class="headerlink" title="在列表中搜索一个元素"></a>在列表中搜索一个元素</h3><p>每当我们使用到搜索的方法时(比如：<strong>IndexOf</strong>、<strong>Contains</strong>或<strong>Find</strong>)，列表执行的是线性搜索。这就意味着，它将会遍历内部Array的所有元素，直到其中的一个与你想要的相匹配。在最糟糕的情况，如果你需要的刚好在末尾，那将会遍历前面所有的元素。所以，这种操作的运行复杂度也是：<strong>O(n)</strong></p><h3 id="使用下标访问一个元素"><a href="#使用下标访问一个元素" class="headerlink" title="使用下标访问一个元素"></a>使用下标访问一个元素</h3><p>当你使用下标去操作一个元素的时候，这种操作和容量是不相关的。并且这也是列表比较好的一点，这种消耗也表示为：<strong>O(1)</strong></p><h3 id="List-in-a-Nutshell"><a href="#List-in-a-Nutshell" class="headerlink" title="List in a Nutshell"></a>List in a Nutshell</h3><p>在末尾增/删和通过下标访问元素的消耗为：<strong>O(1)</strong>，在列表中搜索元素，最糟糕的时候消耗为：<strong>O(n)</strong>。如果你想根据某些条件搜索的话，可以使用 <strong>Dictionary</strong></p><h2 id="Dictionary-lt-TKey-TValue-gt"><a href="#Dictionary-lt-TKey-TValue-gt" class="headerlink" title="Dictionary&lt;TKey, TValue&gt;"></a>Dictionary&lt;TKey, TValue&gt;</h2><p>字典(Dictionary)比较适用于你想使用键(TKey)快速定位到指定项，比如你有一个客户集合，你想用他们的ID快速得到具体信息。对于列表(List)的话，这个操作就会更复杂，消耗更多的内存，就像上面说的，最糟糕时的消耗为：<strong>O(n)</strong>。然而对于字典，这样的搜索会非常快(<strong>O(1)</strong>)，不管字典有多大，消耗都是保持不变的。当在字典中保存或者检索一个对象时，你需要提供一个唯一的并且不为空的键。</p><figure class="highlight csharp"><figcaption><span>Dictionary示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个字典</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, Customer&gt;();</span><br><span class="line"><span class="comment">// 定义并且给一些初始值</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, Customer&gt; </span><br><span class="line">&#123;</span><br><span class="line">  &#123; customer1.Id, customer1 &#125;,</span><br><span class="line">  &#123; customer2.Id, customer2 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用键获取元素</span></span><br><span class="line"><span class="keyword">var</span> customer = dic[<span class="number">111</span>];</span><br><span class="line"><span class="comment">// 使用键移除元素</span></span><br><span class="line">dic.Remove(<span class="number">111</span>);</span><br><span class="line"><span class="comment">// 清空字典</span></span><br><span class="line">dic.Clear();</span><br><span class="line"><span class="comment">// 是否包含键</span></span><br><span class="line"><span class="keyword">var</span> contains_key = dic.ContainsKey(<span class="number">111</span>);</span><br><span class="line"><span class="comment">// 是否包含值</span></span><br><span class="line"><span class="keyword">var</span> contains_value = dic.ContainsValue(customer1);</span><br></pre></td></tr></table></figure><p>可是，为什么字典搜索为更快呢？字典内部也是使用了一个Array存储对象。但是列表每次在增加元素的时候，都把对象添加在末尾(或者指定下标)。而字典每次存储时会用 <strong>散列(GetHashCode)</strong> 计算出一个值，并且用这个值来调整内部Array的长度，然后使用这个值当作索引存储对象。之后，我们每次使用下标查找元素的时候，字典会再次调用<strong>GetHashCode</strong>，计算我们提供的键，用于查找到指定的对象。上面我们说过，使用下标访问元素，这样的消耗为：<strong>O(1)</strong>。所以不想列表需要遍历所有的对象，这也是为什么字典更快的原因。</p><figure class="highlight csharp"><figcaption><span>大致实现概念</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部数组</span></span><br><span class="line"><span class="keyword">var</span> inner_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 提供一个键</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="string">"TheKey"</span>;</span><br><span class="line"><span class="comment">// 来自 dictionary.cs</span></span><br><span class="line"><span class="keyword">var</span> hash = key.GetHashCode() &amp; <span class="number">0x7FFFFFFF</span> % <span class="number">0x255</span>;</span><br><span class="line"><span class="comment">// 需要存放的值</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="number">666</span>;</span><br><span class="line"><span class="comment">// 创建新数组</span></span><br><span class="line"><span class="keyword">var</span> newBuckets = <span class="keyword">new</span> <span class="keyword">int</span>[hash];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash; i++) newBuckets[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 存储对象</span></span><br><span class="line">newBuckets[hash - <span class="number">1</span>] = val;</span><br><span class="line"><span class="comment">// 数组赋值</span></span><br><span class="line">inner_array = newBuckets;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Console.WriteLine(inner_array[hash - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet<t></t></h2><p>散列集(HashSet)，正如其名，存放的元素不能重复的集合。比如：<strong>{1,2,3}</strong>，而且具有顺序无关性，也就是说，<strong>{1,2,2}</strong> 和 <strong>{3,2,1}</strong>是相等的。散列集一般适用于追求超快检索，内容唯一时，比如你有一个订单集合，对于某一订单，你需要快速找到其对应的供应商。散列集和字典有点类似，都是 <strong>基于散列的集合</strong>，所以在查找时消耗都为：<strong>O(1)</strong>。但是散列值只能存放值，而不像字典存放的是键值对。两个个对象是否相等，取决于它们调用 <strong>GetHashCode</strong> 返回的结果。所以，如果你要使用散列集存储自定义的类，你需要去重写 <strong>GetHashCode</strong> 和 <strong>Equals</strong> 这两个方法。</p><figure class="highlight csharp"><figcaption><span>HashSet示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个HashSet</span></span><br><span class="line"><span class="keyword">var</span> hashSet = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="comment">// 增加一个对象</span></span><br><span class="line">hashSet.Add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">hashSet.Clear();</span><br><span class="line"><span class="comment">// HashSet和List的操作大多类似，但是它提供了一些数学运算操作：</span></span><br><span class="line"><span class="keyword">var</span> _1st = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> _2nd = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 两个集合共有的：_1st = &#123; 1 &#125;</span></span><br><span class="line">_1st.IntersectWith(_2nd);</span><br><span class="line"><span class="comment">// 移除两个集合共有的： _1st = &#123; 2, 6 &#125;</span></span><br><span class="line">_1st.ExceptWith(_2nd);</span><br><span class="line"><span class="comment">// 合并两个集合取并集： _1st = &#123; 1, 2, 6 &#125;</span></span><br><span class="line">_1st.UnionWith(_2nd);</span><br><span class="line"><span class="comment">// 还有IsSupersetOf、IsSubsetOf、SetEquals等等</span></span><br></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack<t></t></h2><p>栈(Stack)是一个后进先出(LIFO)的集合，一般使用场景为用户需要可回退功能时。最常见的就是浏览器，你进入新的网址之后，你可以点击后退，返回上一个网址，还有一些就是比如IDE的Ctrl+Z。</p><figure class="highlight csharp"><figcaption><span>Stack示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个Stack</span></span><br><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="comment">// 添加一个新元素</span></span><br><span class="line">stack.Push(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="comment">// 是否包含某元素</span></span><br><span class="line"><span class="keyword">var</span> is_contains = stack.Contains(<span class="string">"https://www.google.com"</span>);</span><br><span class="line"><span class="comment">// 获取末尾元素并删除</span></span><br><span class="line"><span class="keyword">var</span> last_with_delete = stack.Pop();</span><br><span class="line"><span class="comment">// 获取最后一个元素不删除</span></span><br><span class="line"><span class="keyword">var</span> last_without_delete = stack.Peek();</span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure><p>在栈的内部，初始化的时候会声明一个有容量的Array，当你Push一个元素时，如果达到了容量上限，就需要创建一个更大的Array，并且copy以前所有存在的元素，这样的消耗为：<strong>O(n)</strong>。但是，当没达到时，消耗为：<strong>O(1)</strong></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue<t></t></h2><p>与栈不同的是，队列(Queue)是一个先进先出(FIFO)的集合，一般在按顺序执行任务时时候，比如消息队列之类的。<br></p><figure class="highlight csharp"><figcaption><span>Queue示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个队列</span></span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="comment">// 加入队列</span></span><br><span class="line">queue.Enqueue(<span class="string">"task1"</span>);</span><br><span class="line"><span class="comment">// 判断是否包含</span></span><br><span class="line"><span class="keyword">var</span> is_contains = queue.Contains(<span class="string">"taks2"</span>);</span><br><span class="line"><span class="comment">// 获取第一个任务并从队列中删除</span></span><br><span class="line"><span class="keyword">var</span> first_with_delete = queue.Dequeue();</span><br><span class="line"><span class="comment">// 获取第一个任务不删除</span></span><br><span class="line"><span class="keyword">var</span> first_without_delete = queue.Peek();</span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure><p></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>列表(List)使用下标查找元素很快，但是使用搜索的话，就会变慢。<br>字典(Dictionary)提供使用键快速索引出对象，键必须唯一且不能为空。<br>散列集(HashSet)用在需要快速查找元素是否存在时表现得很不错。<br>栈(Stack)的存储方式是LIFO，所以一般遇到可回退，或者撤销之类的情况下。<br>队列(Queue)则是FIFO，用户处理任务以此执行就很合适。</p><a href="https://programmingwithmosh.com/net/csharp-collections/" target="_blank" rel="noopener">原文在这里</a><div class="full-width auto-padding tags"><a href="/tags/CSharp/">CSharp</a> <a href="/tags/译文/">译文</a></div></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Tech/Hexo/hello-world/">Hello World</a></h2><time>Jul 15, 2019</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="article typo"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><div class="full-width auto-padding tags"><a href="/tags/Hexo/">Hexo</a></div></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Tech/Angular/super-pwa-hero/">超级英雄 - PWA</a></h2><time>May 27, 2019</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="article typo"><h2 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h2><p>前面已经讲了 <a href="/_/Tech/Angular/pwa-get-started/" title="怎样成为 “Angular” 英雄">怎样成为 “Angular” 英雄</a> 描述的是官方所给出的 <code>Getting Started</code><br>这次我们来说一下官方给出的另一个 <a href="https://angular.io/tutorial" target="_blank" rel="noopener">Tutorial</a> 步骤都很简单易懂，跟着做就行了，如果不喜欢看English的朋友，可以翻到底部切换语言<br><img class="base64-inline" src="data:image/png;base64,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"><br></p><blockquote class="pullquote"><p>或者也可以地址栏直接输入：<a href="https://angular.cn/tutorial" target="_blank" rel="noopener">https://angular.cn/tutorial</a><br>而且官方还给出里 Live Demo <a href="https://stackblitz.com/angular/kooqabkbaknm" target="_blank" rel="noopener">https://stackblitz.com/angular/kooqabkbaknm</a></p></blockquote><p></p><h2 id="变身-PWA"><a href="#变身-PWA" class="headerlink" title="变身 PWA"></a>变身 PWA</h2><p>在左侧菜单列表里面找到 <code>Techniques -&gt; Service Workers &amp; PWA -&gt; Introduction</code> 并打开。一开始讲了一下成为 PWA 的意义，然后说明 Angular 5.0.0 之后就支持 <code>Service Worker</code>，再说明了一下设计目的和使用CLI就可以创建</p><h3 id="变身条件"><a href="#变身条件" class="headerlink" title="变身条件"></a>变身条件</h3><p>官方这里这里说明了一下 <code>Service worker</code> 能在哪些浏览器能运行，比如 Chrome、Firefox、Safiri等等目前主流的浏览器，还提供了 <a href="https://caniuse.com/#feat=serviceworkers" target="_blank" rel="noopener">Can I Use</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">MDN docs</a>。<br>我们大致知道变身所需要的条件，那我们开始吧，进入 <code>Techniques -&gt; Service Workers &amp; PWA -&gt; Getting Started</code><br></p><blockquote class="pullquote"><p>底部直链： <a href="https://angular.io/guide/service-worker-getting-started" target="_blank" rel="noopener">Getting Started with service workers</a></p></blockquote><p></p><h3 id="开始预热"><a href="#开始预热" class="headerlink" title="开始预热"></a>开始预热</h3><p>打开命令提示符，使用 <code>ng</code> 命令加入 <code>PWA</code> 支持<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng add @angular/pwa --project angular-tour-of-heroes</span><br><span class="line"># angular-tour-of-heroes 为项目名称，即 ng new 这里使用的名字</span><br><span class="line"># 如果忘记了可以在根目录的 angular.json - projects 下面找到</span><br></pre></td></tr></table></figure><br>你肯定也会好奇这条命令做了什么，下面就是它做的事：<p></p><ol><li>添加 <code>@angular/service-worker</code> 依赖，具体可在 <code>package.json</code> 文件查看</li><li>在 <code>CLI</code> 中启用 <code>Service Worker build support</code></li><li>向 <code>App Module</code> 添加 <code>Service Worker Module</code>，详细在 <code>app.moudle.ts</code> 中查看</li><li>修改 <code>index.html</code> 文件内容，包括在<head><meta name="generator" content="Hexo 3.8.0">标签中加入 <code>&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;</code> 和 <code>&lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;</code></head></li><li>创建了 <code>assetes</code> 文件夹，并加入各类尺寸的 <code>icons</code></li><li>还创建了一个叫 <code>ngsw-config.json</code> 的 <code>Service Worker</code> 配置文件</li></ol><h3 id="积蓄能量"><a href="#积蓄能量" class="headerlink" title="积蓄能量"></a>积蓄能量</h3><p>使用命令打包项目供后续调试使用<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ng build --prod</span><br><span class="line"># --prod 以上线的方式打包，即release</span><br></pre></td></tr></table></figure><br>官方这里推荐使用 <a href="https://www.npmjs.com/package/http-server" target="_blank" rel="noopener">http-server</a> 来做本地web服务器，如果你有更好的选择那自然随心<br><code>http-server</code> 安装命令如下：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install http-server -g</span><br><span class="line"># -g 表示全局安装</span><br></pre></td></tr></table></figure><br>这里我使用的是 <a href="https://github.com/johnpapa/lite-server" target="_blank" rel="noopener">lite-server</a>，因为使用 <code>http-server</code> 遇到各种问题…<br><code>lite-server</code> 安装命令：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lite-server -g</span><br></pre></td></tr></table></figure><p></p><p>等打包完毕之后，会在根目录创建一个 <code>dist</code> 的文件夹，自然你也可以在 <code>angular.json</code> 中配置 <code>outputPath</code><br>ok，打开文件夹就知道，所有的都已经打包好了，可以开始部署了，下面使用 <code>lite-server</code> 开启服务<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lite-server --baseDir="dist"</span><br><span class="line"># -baseDir跟outputPath就行了，默认是dist</span><br></pre></td></tr></table></figure><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># http-server 命令如下：</span><br><span class="line">http-server -p <span class="number">8080</span> -c-<span class="number">1</span> dist/&lt;project-name&gt;</span><br><span class="line"># -p 端口号 -c-<span class="number">1</span> 表示禁用缓存 最后跟的是路径/项目名称(同上 添加PWA支持项目名)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>使用 <code>lite-server</code> 执行之后会使用默认浏览器打开，<code>http-server</code> 需要手动打开</p></blockquote><h3 id="变身开打"><a href="#变身开打" class="headerlink" title="变身开打"></a>变身开打</h3><p>是时候表演真正的技术了，你可以使用虚拟机或者手机打开你刚刚部署的网站，但你首先保证你们在同一网域，做法很简单，要么手机开热点给电脑，要么连同一wifi，然后查看电脑ip，手机输入即可<br>不出意外的话，打开之后功能都是存在的，而且都是能用的，这时候把手机的流量关掉刷新网页，你会才会发现变身之后有多强。<br>关闭流量之后，你会惊讶的发现，什么？？？还能使用？？？这也太 <a href="http://dota.178.com/zt/imba/" target="_blank" rel="noopener">IMBA</a> 了吧！！没错，你看到了变身之后的 <code>PWA</code> 的真面目。<br>还有一个很强大的地方就是 - <code>app化</code>，如果你使用的 <code>Iphone</code> 的话，试着使用 <code>safari -&gt; 添加到主屏幕</code>，然后你再打开桌面上新添加的图标，你会更兴奋的。</p><h2 id="附加链接"><a href="#附加链接" class="headerlink" title="附加链接"></a>附加链接</h2><blockquote class="pullquote"><p>非常值得一试！Google 官方出的 <a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" target="_blank" rel="noopener">Tutorial</a><br>Google 官方给的 <a href="https://developers.google.com/web/fundamentals/web-app-manifest/" target="_blank" rel="noopener">Mainifest.json</a><br>还是Google 官方给的 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener">Service Worker 介绍</a><br>自然，以上链接都有中文，在顶部 <code>Language</code> 切换</p></blockquote><div class="full-width auto-padding tags"><a href="/tags/Angular/">Angular</a> <a href="/tags/Javascript/">Javascript</a> <a href="/tags/PWA/">PWA</a> <a href="/tags/Tutorial/">Tutorial</a></div></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Tech/Angular/become-an-angular-hero/">怎样成为 “Angular” 英雄</a></h2><time>May 25, 2019</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="article typo"><h2 id="PWA，第一步从Angular开始"><a href="#PWA，第一步从Angular开始" class="headerlink" title="PWA，第一步从Angular开始"></a>PWA，第一步从Angular开始</h2><p>我这里使用的 <a href="https://angular.io/guide/quickstart" target="_blank" rel="noopener">Angular</a> 版本为：stable v7.2.15，它的准备条件如下：</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a> version 8.x or 10.x.</li><li>npm package manager(npm) 并没有要求版本，安装Nodejs的时候会一起安装</li></ul><p>如果你已经安装过，可以在命令提示符中通过以下命令查看：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\User&gt;node -v</span><br><span class="line">v11.12.0</span><br><span class="line"></span><br><span class="line">C:\Users\User&gt;npm -v</span><br><span class="line">v6.7.0</span><br></pre></td></tr></table></figure><p></p><h2 id="安装-Angular-CLI"><a href="#安装-Angular-CLI" class="headerlink" title="安装 Angular CLI"></a>安装 Angular CLI</h2><p>这是官方推出的脚手架工具，集成了你完成整个项目所需要的一切功能<br>包括创建项目、生成应用和所依赖的库，再者就是测试、打包、发布，所以推荐全局安装(-g)<br>在刚刚打开的命令提示符中输入如下命令：<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br></pre></td></tr></table></figure><br>如果安装过程出现速度过慢，或者报错异常的问题，那推荐使用<a href="https://npm.taobao.org/" target="_blank" rel="noopener">cnpm</a><p></p><h2 id="开始创建项目"><a href="#开始创建项目" class="headerlink" title="开始创建项目"></a>开始创建项目</h2><p>继续在命令提示符输入：<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在C盘创建一个叫 angluar 的文件夹并且 <span class="built_in">cd</span> 到该目录</span><br><span class="line"><span class="built_in">mkdir</span> c:\angular &amp; <span class="built_in">cd</span> c:\angluar</span><br><span class="line"># 使用 ng 命令创建一个项目</span><br><span class="line">ng new my-app</span><br><span class="line"># 执行上面这条命令之后，会提示是否启用 Angluar routing和使用什么来写css</span><br><span class="line"># 如果不懂的或者不想看的直接一路回车即可，后续也会讲到怎么使用这些功能</span><br></pre></td></tr></table></figure><p></p><h2 id="跑起"><a href="#跑起" class="headerlink" title="跑起"></a>跑起</h2><p>最后两行代码：<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入刚刚创建的项目，CLI会自动创建一个同名的文件夹</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line"># 使用 ng 命令 run 起来</span><br><span class="line">ng serve --open</span><br><span class="line"># --open 表示使用默认浏览器打开，Angular默认监听的端口是<span class="number">4200</span></span><br><span class="line"># 可以通过 --port port 来指定你想监听的端口</span><br></pre></td></tr></table></figure><p></p><h2 id="出现呐，那个“男人”"><a href="#出现呐，那个“男人”" class="headerlink" title="出现呐，那个“男人”"></a>出现呐，那个“男人”</h2><p>官方的 Getting Started 到这里也就结束了，CLI 工具很简单易用<br>三句代码就能创建一个能跑起来的项目，只是这文件夹嘛…<br><img class="base64-inline" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVMAAACvCAMAAAB3ss2QAAAC+lBMVEX///8AAACgoKDj6e+rrbP/97Li4+rb3+b/9br+6Z7+/v77+/v6+fn047jqzk/19fb+/PXy8vLv3K7m0Zzt2IfHr1nqzUzt7e3p6enx4bX57LT47rLs2an256P16KL25Z3gzZnr14n23HP23HLt1GLVvVumi0D//vr4+Pjp7PDk5OTb29v79M3Jycn25rv477jx37L+8a/t2qv+86r36afp1qPo15Pr1o3YxYH33nfTvnHv2HDgy3Du1mrGsGS8pmK5olm7ok+ulEmtlEX9/f39+/L+++fg4OD9+N7X19f99tb89NT/+MH36L7577v47Lb68LX47K336q3d0Kv37Kj98qbo16b98KLo1KD16Z7955r87Jnw3pfp2pb76pTv3ZPu3I/l1I766I3u24zez4zk0oj55Yfu24fx4YXy3oXv3oXr1oP44oH4333y23zQv3zhzXvp1HrWwnnbx3TItHDArGjmzWXfx2TPumPawVy0nVrfxFXqz1Ovl07///z5+PT8+OLf4OLr59707Nn/+9TS0tL689D9+M/Ozs747sz68sr78sTu48O7vcLo3cH58L3CwL3/9Ln987fq3bb/97T/9rD47K/+9a7566vCuar87abTxqPw4p3y5Jf95ZT04ZL5447z347kzoisnYfbyob63oXezYTx3YHfyn/l0X7Qu3vl0Hjw2XblzXTLtnHo0W/ZwmzgyGrRu2rXwGS5pF/QuV7ErV7QuFzgxlnYv1fsz1aymlW4oFOwmFL//vH48+ekx+L//N7k4dji3dbz6dHb1tDk3c3w5cnVz8f57cb/+cXMysTDw8P678LQysH38MCIqb//97bz6bXJwrXi17HTya787qr46qfXyqb76qD875/t2Z+6rp387Zz66Jv04pbm0ZWypJDz5Y3jy42/r4374Iu0pYro0InGtIny4oT13X7q1X3IsXrdyHnw2njNunbErm7Hs2nGsmjcw2LfzWHq0F7s0Vvs0FuslFrfylnQt1m8o1Ohh1K4n1FT7HuDAAAHPUlEQVR4AWIYrGAUjIJRMApGwSgYBaNgFIwC186uBleqmjgKOgN89aTlQqT7ddwEqGPiKNDjCPANu6QPBCGRcyOlz7e5qVNs5miYcvr4KiybKxfYr+PlpdMt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"></p><div class="full-width auto-padding tags"><a href="/tags/Angular/">Angular</a> <a href="/tags/Javascript/">Javascript</a> <a href="/tags/PWA/">PWA</a> <a href="/tags/Tutorial/">Tutorial</a></div></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Tech/Angular/pwa-get-started/">猜猜我是谁？PWA.</a></h2><time>May 25, 2019</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="article typo"><h2 id="你在草丛遭遇了-铁甲蛹"><a href="#你在草丛遭遇了-铁甲蛹" class="headerlink" title="你在草丛遭遇了 - 铁甲蛹"></a>你在草丛遭遇了 - 铁甲蛹</h2><h3 id="你的小火龙使用了-利爪-效果一般"><a href="#你的小火龙使用了-利爪-效果一般" class="headerlink" title="你的小火龙使用了 [利爪] - 效果一般"></a>你的小火龙使用了 [利爪] - 效果一般</h3><p>最近一段时间接触到了 <code>[PWA]</code> 这个是在2015年，Google I/O 首次提出，它的特点如下：<br></p><blockquote><p><code>Full responsiveness and browser compatibility.</code> These apps are built according to progressive enhancement principles. Progressive enhancement is the web design strategy of providing the basic functionality and content to everyone regardless of browsers they use or connection quality while delivering more sophisticated page versions to users whose newer browsers can support them.</p><p>So, PWAs work with all browsers and are compatible with any device, regardless of screen size and other specifications. Tablet and mobile users will have the same experience. You can even adjust the app to the desktop if needed.</p><p><code>Connectivity independence.</code> Progressive web applications can work both offline and on low-quality networks.</p><p><code>App-like interface.</code> These apps mimic navigation and interactions of native apps.</p><p><code>Push notifications.</code> If used as a part of a good messaging strategy, push notifications can keep customers interested, motivating them to open and use an app more.</p><p><code>Self-updates.</code> Able to update themselves automatically, apps stay fresh.</p><p><code>Safety.</code> These apps are served through HTTPS, so unauthorized users can’t access their content.</p><p><code>Discoverability and easy installation.</code> While search engines classify PWAs as applications, they are not distributed via app stores. These apps can be shared through a URL instead so they’re easily found. The installation is simple and entails visiting a site and adding it to a device home screen.</p><footer><strong>altexsoft</strong><cite><a href="https://www.altexsoft.com/blog/engineering/progressive-web-apps/" target="_blank" rel="noopener">www.altexsoft.com/blog/engineering/progressive-web-apps</a></cite></footer></blockquote><p></p><h3 id="你的小火龙使用了-火苗-效果拔群"><a href="#你的小火龙使用了-火苗-效果拔群" class="headerlink" title="你的小火龙使用了[火苗] - 效果拔群"></a>你的小火龙使用了[火苗] - 效果拔群</h3><p>以上是英语版本的特点总结，自然也有比较友好的中文特点总结：</p><ul><li><p><code>渐进式</code> - 适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。</p></li><li><p><code>自适应</code> - 适合任何机型：桌面设备，移动设备，平板电脑或任何未来设备。</p></li><li><p><code>连接无关性</code> - 能够借助于服务工作线程(Service Worker)在离线或低质量网络状况下工作。</p></li><li><p><code>类似应用</code> - 由于是在App Sheel模型基础下开发，因此具有应用风格的交互和导航，让用户有原生应用的感觉。</p></li><li><p><code>持续更新</code> - 因为有服务工作线程的加持，能够时刻保持最新状态。</p></li><li><p><code>安全</code> - 强制要求使用 HTTPS，以防止窥探和确保内容安全性。</p></li><li><p><code>可发现</code> - 使用 W3C 指定的Mainfest和服务工作线程的作用，让搜索引擎找到它们的时候被识别为“应用”。</p></li><li><p><code>可再互动</code> - 可以向用户推送通知。</p></li><li><p><code>可安装</code> - 用户可以免去使用应用商店的麻烦，可以直接将其“保留”在主屏幕上。</p></li><li><p><code>可链接</code> - 可以任意的通过链接分享给他人。</p></li></ul><h2 id="你获得了-Official-Case、-Official-Video"><a href="#你获得了-Official-Case、-Official-Video" class="headerlink" title="你获得了 Official Case、 Official Video"></a>你获得了 Official Case、 Official Video</h2><a href="https://developers.google.com/web/showcase/2016/iowa2016" target="_blank" rel="noopener">Official Case</a> <a href="https://www.youtube.com/watch?v=__KvYxcIIm8&feature=youtu.be" target="_blank" rel="noopener">Youtube Video</a><div class="full-width auto-padding tags"><a href="/tags/Angular/">Angular</a> <a href="/tags/Javascript/">Javascript</a> <a href="/tags/PWA/">PWA</a></div></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Dev/windows-service-memory-detector/">Windows服务内存监听</a></h2><time>May 22, 2019</time><div class="cats"><a href="/categories/foo系编程/">foo系编程</a></div></section><section class="article typo"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>一大早上班的时候，发现 chrome 浏览网页很卡，试着回收一下<br></p><figure class="highlight plain"><figcaption><span>Command</span><a href="https://www.webnots.com/useful-chrome-url-commands/" target="_blank" rel="noopener">Chrome Commands</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chrome:://restart</span><br></pre></td></tr></table></figure><p></p><blockquote><p>注: 此命令会关闭隐私窗口, 不能恢复…</p></blockquote><p>等 Chrome 重启之后，结果依然很卡…那就废话不多说，直接开大(<strong>Win + R</strong>)<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">User</span>&gt; <span class="title">taskmgr</span></span></span><br></pre></td></tr></table></figure><p></p><p>发现是本地的 <a href="http://gitblit.com/" target="_blank" rel="noopener">gitblit</a> 居然吃了我 <strong>40w+</strong>的内存，这个明显不能忍啊，直接给它来一套: <strong>net stop gitblit</strong><br>只听 TaskManager 这样给我说：<img class="base64-inline" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAZCAMAAAAc9R5vAAAAElBMVEWBlKoA/wAAgAD///+AgIAAAAA34p8fAAAAJklEQVR4AWMYBIAFAZhRJViZYBBNggkOBkAHIxwMgAQzAjAMRQAAFFIBeToXnQgAAAAASUVORK5CYII="> =&gt; <img class="base64-inline" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAZCAMAAAAc9R5vAAAAElBMVEUAAAAAgAAA/wCAgICBlKr///8XGZNTAAAAK0lEQVR4AWNgwQHoKMGMAKyoEgyMMIgmwQgHQ1sHExwQK8GKADhDdzBLAACjcwgSt1J0wAAAAABJRU5ErkJggg=="><br>看来它已经懂我意思了</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>突然灵光一闪，我能不能做一个自动检查服务内存，到了一定的阈值自动关闭呢？<br>感觉是一个好想法，那就实现简单实现一下吧…<br>经过一段时间的捣腾，火光四溅之后，代码已经打包压缩好了，链接在文末</p><h2 id="项目说明："><a href="#项目说明：" class="headerlink" title="项目说明："></a>项目说明：</h2><p>我使用的是 Microsoft Visual Studio 2017(version 15.9.11)<br>如果使用较低版本的朋友，可以直接打开里层目录的 <code>.csproj</code> 文件</p><h3 id="起主要作用的Class"><a href="#起主要作用的Class" class="headerlink" title="起主要作用的Class"></a>起主要作用的Class</h3><ol><li><p><code>ServiceController</code> 位于 <code>System.ServiceProcess</code> 命名空间下，需要手动添加引用</p><blockquote><p>这个类主要用于获取当前所有的Services，使用静态方法 <code>GetServices</code> 就能拿到所有的服务<br>其中包括所有状态(Stopped、StartPending、StopPending、Running、ContinuePending、PausePending、Paused)<br>还有 <code>ServiceType</code> 之分，详情请查阅 <code>Enum</code> - <code>System.ServiceProcess.ServiceType</code></p></blockquote></li><li><p><code>PerformanceCounter</code> 它住在 <code>System.Diagnostics</code>，引入命名空间即可</p><blockquote><p>内存使用量的查询主要用到了它，这个类的构造函数第一个需要传入 <code>categoryName</code>，这个分类存在很多<br>具体可在 <code>性能监视器</code> 查看，<a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.performancecounter?view=netframework-4.5.2" target="_blank" rel="noopener">附上官网的例子</a>，也可以使用 <code>perfmon</code> 查看，使用 <code>Win + R</code> 输入即可</p></blockquote></li><li><p>还有就是 <code>ManagementObjectSearcher</code> 住在 <code>System.Management</code> 也需要手动添加</p><blockquote><p>使用过 <code>WMI</code> 的应该都知道，简单点说就是如果你需要电脑的硬件信息，那很大可能你都会使用到它<br>在项目中主要用于查询某个 <code>Service</code> 相关联的 <code>ProcessId</code>，因为服务的名称是可以自定义的<br>运行的程序有可能名字不相同，所以需要去查询一下对应的Process</p></blockquote></li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="./ServiceMemoryDetector.7z">Download</a></p><div class="full-width auto-padding tags"><a href="/tags/CSharp/">CSharp</a> <a href="/tags/Windows/">Windows</a></div></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/GVan/hello-game/">Hello Game</a></h2><time>May 21, 2019</time><div class="cats"><a href="/categories/🎮-SKILL/">🎮 SKILL</a></div></section><section class="article typo"></section></article></div><div class="post-wrapper"><article class="post reveal"><section class="meta"><h2 class="title"><a href="/_/Tech/Hexo/begin-with-hexo/">从Hexo开始</a></h2><time>May 21, 2019</time><div class="cats"><a href="/categories/技能加点/">技能加点</a></div></section><section class="article typo"><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>从 <strong>1558407365744</strong> 开始, blog 开始启用, 用于记录日常学习的知识，还有一些生活相关。</p><h2 id="accomplice"><a href="#accomplice" class="headerlink" title="accomplice"></a>accomplice</h2><p>本博客使用 <strong>Hexo</strong> 引擎强力驱动，底部有此主题作者以及地址，再加上魔改一番，就出现了现在这个样子。</p><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>为什么要魔改呢，因为多半有病，强迫症太严重了，看到gen出来的 <strong>文件夹不规则</strong> ，不符合自己的想法，一个字 <strong>改</strong> ，主题里面 <strong>宽高</strong> 不符合自己的风格， <strong>改!!!</strong></p><h2 id="joke"><a href="#joke" class="headerlink" title="joke"></a>joke</h2><p>然后就出现了现在这个样子的博客，各位看官请将就着看，如果你们是 <strong>李荣浩</strong> 铁粉的话，右上角 (溜😅</p><h2 id="remark"><a href="#remark" class="headerlink" title="remark"></a>remark</h2><p><strong>Hexo</strong> 初始化的 <strong>Hello World</strong> 并没有删除，希望更多人进入 <strong>Hexo</strong> 的世界。</p><div class="full-width auto-padding tags"><a href="/tags/Hexo/">Hexo</a></div></section></article></div></section></div><aside class="l_side"><section class="m_widget about"><img class="avatar waves-image" src="/avatar.png"><div class="header"></div><div class="content"><div class="desc">Tempora mutantur, nos et mutamur in illis ...</div></div></section><section class="m_widget links"><div class="header">Links</div><div class="content"><ul class="entry"><li><a class="flat-box" target="_blank" href="https://www.google.com/"><div class="name">Google</div></a></li></ul></div></section><section class="m_widget categories"><div class="header">Categories</div><div class="content"><ul class="entry"><li><a class="flat-box" href="/categories/foo系编程/"><div class="name">foo系编程</div><div class="badget">1</div></a></li><li><a class="flat-box" href="/categories/技能加点/"><div class="name">技能加点</div><div class="badget">6</div></a></li><li><a class="flat-box" href="/categories/🎮-SKILL/"><div class="name">🎮 SKILL</div><div class="badget">1</div></a></li></ul></div></section><div class="m_widget tagcloud"><div class="header">Tags</div><div class="content"><a href="/tags/Angular/" style="font-size:20px;color:#000">Angular</a> <a href="/tags/CSharp/" style="font-size:17px;color:#404040">CSharp</a> <a href="/tags/Hexo/" style="font-size:17px;color:#404040">Hexo</a> <a href="/tags/Javascript/" style="font-size:20px;color:#000">Javascript</a> <a href="/tags/PWA/" style="font-size:20px;color:#000">PWA</a> <a href="/tags/Tutorial/" style="font-size:17px;color:#404040">Tutorial</a> <a href="/tags/Windows/" style="font-size:14px;color:grey">Windows</a> <a href="/tags/译文/" style="font-size:14px;color:grey">译文</a></div></div></aside><script>setLoadingBarProgress(60)</script></div></div><footer id="footer" class="clearfix"><div class="social-wrapper"></div><div>Theme <a href="https://github.com/stkevintan/hexo-theme-material-flow" class="codename">MaterialFlow</a> designed by <a href="https://github.com/stkevintan" target="_blank">Kevin Tan</a>.</div></footer><script>setLoadingBarProgress(80)</script><script src="/js/jquery.min.js"></script><script src="/js/waves.min.js"></script><script src="/js/scrollreveal.min.js"></script><script src="/js/jquery.fitvids.js"></script><script>var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>setLoadingBarProgress(100)</script></body>